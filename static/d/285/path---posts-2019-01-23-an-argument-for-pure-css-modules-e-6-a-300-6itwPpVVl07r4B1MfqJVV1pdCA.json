{"data":{"markdownRemark":{"html":"<h1>üëÅ üòç Pure CSSModules</h1>\n<p>For better or for worse here are my current opinions on Styling React Components.</p>\n<p>tldr;</p>\n<ul>\n<li>CSS should be used to describe <em>How</em> a component is displayed by the <em>browser</em></li>\n<li>CSS Needs To Be Less Global</li>\n<li>Pure CSSModules are the Only Styling Most Applications Need</li>\n</ul>\n<h2>‚≠êOpinion 1: CSS should be used to describe <em>How</em> a component is displayed by the <em>browser</em></h2>\n<h3>Alternatives</h3>\n<p>To understand why I hold this opinion, its important to consider the alternative approaches:</p>\n<ul>\n<li>Inline JSX Styles</li>\n<li><code>&#x3C;style></code> tag Injecting Libraries (<a href=\"https://github.com/FormidableLabs/radium\">Radium</a>, <a href=\"https://www.styled-components.com/\">StyledComponents</a>)</li>\n</ul>\n<p>Chris Coyier put a lot of thought into this argument in his article <a href=\"https://css-tricks.com/the-debate-around-do-we-even-need-css-anymore/\">The Debate Around 'Do We Even Need CSS Anymore?'</a>.\nHe outlines the following advantages for Inlining styles over CSS: </p>\n<ul>\n<li>Cascade-less</li>\n<li>All Javascript</li>\n<li>Dynamic Styles</li>\n</ul>\n<h3>Technical Benefits</h3>\n<p>While its easy to use they arguments to convince yourself to use an inline approach, to me its advantages are what brought me back:</p>\n<ul>\n<li>Cachability - by separating styles into a separate stylesheet, the cachability of these assets is improved</li>\n<li>Specificity Spectrum Obfuscation - Javascript approaches often deny or at a minimum obfuscate the specificity spectrum feature of CSS <code>!important</code>.  Each approach compromises it for different reasons.  For example, inline styles are the top of the spectrum, so to override any inline style an <code>!important</code> is required</li>\n<li>States - <code>:hover</code>, <code>:focus</code>, etc. are not supported in Inline Styles</li>\n<li>Custom Browser Optimizations and hooks - Using rules specific for browsers <code>-moz</code>, and GPU enabled transforms etc, are just not possible with inline styles</li>\n</ul>\n<p>Most of these only apply to InlineStyles.  Dynamically adding many <code>&#x3C;style></code> tags has a memory and CPU performance concern on the browser.\n<a href=\"https://www.styled-components.com/\">StyledComponents</a> also adds many extra <code>div</code> elements making the markup of the site messy, and increasing memory and CPU requirements of the site.</p>\n<p>Talia Marcassa makes a great point in <a href=\"https://medium.com/building-crowdriff/styled-components-to-use-or-not-to-use-a6bb4a7ffc21\">Styled Components: To Use or Not to Use?</a></p>\n<blockquote>\n<p>Use Styled Components for elements whose styling (colours, images, etc.) is configured by the user</p>\n</blockquote>\n<p>Having used both CSSMoudles, Sass, and Inline Styles to implement a user definable style, I can definitely see how <a href=\"https://www.styled-components.com/\">StyledComponents</a> is the right tool for that job.\nIn this use case I would consider using <a href=\"https://www.styled-components.com/\">StyledComponents</a>, but in other cases, I simply feel that it is unnessisary.</p>\n<h3>üññSpeaking The Right Language</h3>\n<p>Besides the technical reasons I prefer using CSS, there is also a social driver as well.</p>\n<p>In essence, CSS is a language for describing <em>how</em> elements should be displayed by a browser.\nSince this is usually <em>negotiated between developers and designers</em> it seems logical to consider Conway's Law when making technical desisions about that relationship.</p>\n<blockquote>\n<p> Any organization that designs a system (defined more broadly here than just information systems) will inevitably produce a design whose structure is a copy of the organization's communication structure ~ Melvin Conway (<a href=\"http://www.melconway.com/Home/Committees_Paper.html\">Conway's Law</a>)</p>\n</blockquote>\n<p>In this regard, Conway's Law suggests that the system design should consider the channel between design and engineering.</p>\n<p>While expecting a designer to grok inline JSX or <code>style</code> tag injection could be stretch, most designers can communication in CSS.</p>\n<p>For this reason alone, I am prone to prefer a CSS Solution.</p>\n<h3>Communication Channels When Creating Components:</h3>\n<img width='800' src='/images/posts/2019-01-23-speaking-dev.svg' />\n<h1>‚≠êOpinion 2: CSS Needs To Be Less Global</h1>\n<p>As Opinion 1 states, I believe styles usually belong in CSS.  However, I also believe that CSS is flawed.</p>\n<p>It is simple - CSS is global by default, and this causes namespace pollution and component coupling.</p>\n<p>CSSModules does one simple thing:</p>\n<blockquote>\n<p>A CSS Module is a CSS file in which all class names and animation names are scoped locally by default. ~ <a href=\"https://github.com/css-modules/css-modules\">CSSModules</a></p>\n</blockquote>\n<p>It does this by creating unique style names for each component:</p>\n<pre><code>/* ./src/Components/styles.module.css */\n.item {\n  background: blue;\n}\n\n// ./src/Component1/index.jsx\nimport styles from './styles.module.css'\nconsole.log(Object.keys) // ['.style-module--Component1-item-3TXyA']\nexport default(() => &#x3C;div className={styles.item} />)\n\n/* ./src/Component2/styles.module.css */\n.item {\n  background: black;\n}\n\n// ./src/Component2/index.jsx\nimport styles from './styles.module.css'\nconsole.log(Object.keys) // ['.style-module--Component2-item-0YoeF']\nexport default(() => &#x3C;div className={styles.item} />)\n</code></pre>\n<p>In many ways this makes CSSModules an automated version of a system like <a href=\"http://getbem.com/\">BEM</a>.</p>\n<h2>Refuting Inline Styles</h2>\n<p>The simple act of exporting unique module names, essentially makes inline styles a poor choice over CSSModules.\nCSSModules are widely supported by all JSX compilers, and are included by default in <a href=\"https://facebook.github.io/create-react-app/docs/adding-a-css-modules-stylesheet\">Create React App</a>.</p>\n<p>With CSSModules the case for Inline Javascript dissapears.  Consider this example which showcases the advantages of CSS while accomplishing the goals of Inline Styles:</p>\n<pre><code>// ./styles.module.css\n@theme-font-size: 10px;\n\n:global {\n  body {\n    color: linen;\n  }\n}\n\n.cascada {\n  font-size: $theme-font-size;\n}\n\n.cascada a {\n  text-decoration: underline;\n}\n\n.cascada--highlight {\n  composes: cascada;\n  background-color: yellow;\n}\n\n.cascada--highlight:hover a {\n  background-color: black;\n  color: white;\n}\n\n\n// index.js\nimport styles from {'./styles.module.css'}\nexport default((props) => {\n  const cascadaClass = props.modifier ? styles.cascada : .style.cascada--highlight\n  return (\n    &#x3C;div className={props.containerClassName || styles.cascada}>\n      &#x3C;a>Some Link&#x3C;/a>\n    &#x3C;/div>\n  )\n})\n</code></pre>\n<p>Unlike Inline Styles, CSSModules allow the developer to control tame the Cascade.\nAdditionally, we can see the use of logic when selecting between <code>cascada</code> and <code>cascada--highlight</code> classes (notice the influence of BEM on the class names in this module).</p>\n<p>The compiler will create one concatenated CSS file with the unique classes.</p>\n<p>This makes the site more cachable.</p>\n<h3>The biggest benefit</h3>\n<p>This is just CSS.  This means a designer can grok it.  </p>\n<h1>‚≠êOpinion 3: Pure CSSModules are the Only Styling Most Applications Need</h1>\n<p>At this point, there is only one other big option left unturned which is Sass.</p>\n<p>Sass has a few downsides:</p>\n<ul>\n<li>node-sass is a compiled node package, and its a piece of garbadge.  When it comes to CI, build speed, etc. this library is always a bottle neck.  I think I have spent more time in my life debugging node-sass than I have writing css.  Which is why I opt to just write the CSS.</li>\n<li>The nested <code>&#x26;</code> operator and <code>mixins</code>, obfuscate class names from source code in an extreme mannor.  In some cases it can take a very long time to identify the source of a rule.  Much longer than just writing CSS.</li>\n<li>Too many options leads to overengineered styling.  Just as <a href=\"https://en.wikipedia.org/wiki/Occam&#x27;s_razor\">Occam's Razor</a> states, the simplest solution is the best solution, and in the following case I believe CSS is the more simple solution:</li>\n</ul>\n<pre><code>/* ./src/components/Component1/styles.module.css\n.item { background: black }\n.item:hover { background: smoke }\n.item__modified { background: blue }\n.item__special { composes special from '../../shared/special.module.css' }\n\n/* ./src/shared/styles/special.module.css\n.special {\n  background: green;\n}\n\n// ./src/components/Component1/styles.scss\ninclude '../../shared/special.scss'\n.Component1 {\n  .item {\n    background: black;\n    &#x26;:hover { background: smoke; }\n    __modified: { background: blue; }\n    __special { extends %special }\n  }\n}\n\n// ./src/components/shared/special.scss\n@mixin special {\n  background: green;\n}\n</code></pre>\n<h1>Conclusion</h1>\n<p>In my opinion, the solution with CSSModules is often not only more simple, shorter, but its also legible to a wider audience than the alternatives.</p>","frontmatter":{"title":"An Argument for Pure CSSModules","hero":null},"fields":{"date":"2019-01-23"}}},"pageContext":{"url":"/posts/2019-01-23-an-argument-for-pure-css-modules/"}}