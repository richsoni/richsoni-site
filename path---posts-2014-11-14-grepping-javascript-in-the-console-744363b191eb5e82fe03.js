webpackJsonp([0x72f3752231a8],{763:function(e,n){e.exports={data:{markdownRemark:{html:"<p><a class='caption' target=\"_blank\" href='https://www.flickr.com/photos/thomasfisherlibrary/5954552837/in/photolist-a5bD76-8yo9on-8yroiu-cvpQNC-cvpQrA-kUxRG-6oM741-amN8eE-4uZddZ-EHLrQ-5Aphtr-2kdVUj-5keipH-eNhxFg-e9S1dg-2WajBx-e9S1ie-e9S19T-9sau5q-e9S1me-e9RZTV-e9S13z-e9S118-4Vny19-e9XF8U-e9XF6Y-3APYDN-27mzPz-e9RZMH-gsXzfr-2ZkT1k-4uyKqW-2ZkT7k-asosyR-asLrL7-6UU7yG-aeb3H1-9NGqDK-3iaHSo-asoxHR-asoypr-asrcfj-eA2h8-8gHYuy-dCKMCY-dCKRi7-bnsD2k-asrbUW-9NBZKi-djPA8w'>Header Photo credit to Thomas Fischer Rare Book Library</a></p>\n<h1>Panning for Rubies</h1>\n<p>It is difficult to wrangle long hashes, and big objects when debugging.\nOften times, you know the name of the attribute or method, and need to visually scan through a list.\nRuby has a built in solution to make this process less painful:  The <code>object.methods.grep</code> and <code>hash.keys.grep</code> patterns.\nHere is each one in action:</p>\n<h2>Sifting Arrays</h2>\n<p>Filtering through arrays in Ruby is as easy as using the <code>grep</code> command.</p>\n<pre><code>> hash.methods.length\n => 147\n> hash.methods.grep /to_/\n=> [:to_hash, :to_h, :to_a, :to_s, :to_enum]\n</code></pre>\n<p>Instead of reading through a list of 147 entries, the programmer can filter it to what is important.</p>\n<h1>Feeling the Pain</h1>\n<p>A common painpoint faced in javascript is sifting through json keys.\nSometimes you know the key is something like <code>reference_number</code>, but <code>object.reference_number</code> is undefined.\nIn this case, you may need to pop open the object and read through the list.\nIf the key was <code>order_reference_number</code> it may be hard to find.\nuspecially in a long list.</p>\n<h1>A Solution</h1>\n<p>Here are two small tools inspired by Ruby's <code>grep</code> to mitigate this pain:</p>\n<pre><code class=\"language-javascript\">Array.prototype.grep = function (regex) {\n  this.filter( function (elem) {\n    return elem.match(regex)})}\n\nObject.grepKeys = function (object, regex) {\n  Object.keys(object)\n    .grep(regex)\n    .reduce(function(memo, val){\n      memo[val] = object[val];\n      return memo}, {})}\n</code></pre>\n<p>With these methods at hand, wrangling arrays, and objects becomes much simpler:</p>\n<pre><code class=\"language-javascript\">> array = ['foo', 'bar', 'baz']\n> array.grep(/b/)\n['bar', 'baz']\n> array.grep(/ar/)\n['bar']\n\n> obj = [foo: 1, bar: 1, baz: 1]\n> Object.grepKeys(obj, /oo/)\n{foo: 1}\n> Object.grepKeys(obj, /[^b]/)\n{bar: 1, baz: 1}\n</code></pre>\n<p>I dont actually use these functions in my application code, but include them to make debugging less painful.</p>\n<h2>For The Faint Hearted</h2>\n<p>Some are weary of overwriting builtin prototypes.\nThis currying solution provided by <a href=\"http://www.reddit.com/r/javascript/comments/2maw9q/sifting_for_javascript_ruby_style/\">Ampersand55 on reddit</a> may suit them better than the above solution.</p>\n<pre><code>function grep(regex) {\n  return function(el) {\n    return regex.test(el)\n  }\n}\n</code></pre>\n<p>Enjoy, and happy coding!!!</p>",frontmatter:{title:"Sifting for Javascript, Ruby Style"},fields:{date:"2014-11-14"}}},pathContext:{url:"/posts/2014-11-14-grepping-javascript-in-the-console/"}}}});
//# sourceMappingURL=path---posts-2014-11-14-grepping-javascript-in-the-console-744363b191eb5e82fe03.js.map